#!/usr/bin/env ruby
#
# Usage: robot-status-board [-v] [repository:]workflow
#        where repository = 'dor' by default
#
# @example
#   robot-status-board accessionWF
#
require 'optparse'
require 'awesome_print'
require 'nokogiri'
require 'restclient'

WQ = 'https://localhost/workflow/workflow_queue'

class RobotStatusBoardCLI

  def count_ready step, prereq, lane
    uri = "#{WQ}?waiting=#{step}&completed=#{prereq}&lane-id=#{lane}&count-only=true"
    xml = RestClient.get uri
    doc = Nokogiri::XML(xml)
    doc.root['count'].to_i    
  end

  def count_status step, lane, type
    r, w, s = step.split(/:/)
    uri = "#{WQ}?repository=#{r}&workflow=#{w}&#{type}=#{s}&lane-id=#{lane}&count-only=true"
    xml = RestClient.get uri
    doc = Nokogiri::XML(xml)
    doc.root['count'].to_i
  end

  def doit(repo, wf, flags = {})
    lane = flags[:lane]
    status = {}
    fn = "config/workflows/#{repo}/#{wf}.xml"
    doc = Nokogiri::XML(File.read(fn))
    doc.root.xpath('.//process').each do |p|
      step = p['name']
      fstep = [repo, wf, step].join(':')
      STDERR.puts "Processing step #{step}" if flags[:debug]
      status[step] = {}
      n = count_status(fstep, lane, 'waiting')
      status[step][:waiting] = n
      status[step][:ready] = n # assuming no prereqs
      p.xpath('prereq/text()').each do |pr| # XXX: assuming single prereq
        n = count_ready(fstep, [repo, wf, pr.to_s].join(':'), lane)
        status[step][:ready] = n
      end
      %w{error queued completed}.each do |s|
        status[step][s.to_sym] = count_status(fstep, lane, s)
      end
    end
    # ap({:status => status})
    puts ['lane', 'step', 'waiting', 'ready', 'error', 'queued', 'completed'].join(' | ')
    puts ['----', '----', '-------', '-----', '-----', '------', '---------'].join(' | ')
    status.each do |k, v|
      puts ["#{lane}", "#{k}", "#{v[:waiting]}", "#{v[:ready]}", "#{v[:error]}", "#{v[:queued]}", "#{v[:completed]}"].join(' | ')
    end
  end
  
  def run(args)
    flags = {
      :verbose => false,
      :debug => false,
      :repository => 'dor',
      :lane => 'default'
    }
    
    args = %w{--help} if args.nil? or args.empty?
  
    OptionParser.new do |opts|
      opts.banner = "Usage:\t#{File.basename(__FILE__)} [flags] [repo:]workflow"
      opts.on('-v', '--verbose', 'Run verbosely, use multiple times for debug level output') do
        flags[:debug] = true if flags[:verbose]  # -vv
        flags[:verbose] = true
      end
      opts.on('--lane LANE', 'Use given lane') do |l|
        flags[:lane] = l
      end
    end.parse!(args)
    ap({:args => args}) if flags[:debug]
    
    # Initialize the workflow, and set the repository if prepended with :
    flags[:workflow] = args.shift
    raise ArgumentError, "Missing required workflow" if flags[:workflow].nil?
    if flags[:workflow] =~ /:/
      flags[:repository], flags[:workflow] = flags[:workflow].split(/:/, 2)
    end    
    ap({:flags => flags}) if flags[:debug]

    doit(flags[:repository], flags[:workflow], flags)
  end
end

# __MAIN__
RobotStatusBoardCLI.new.run(ARGV)
